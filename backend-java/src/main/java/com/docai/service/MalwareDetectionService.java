package com.docai.service;

import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Service;
import org.springframework.web.multipart.MultipartFile;

import java.io.IOException;
import java.io.InputStream;
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;
import java.util.*;
import java.util.regex.Pattern;

@Slf4j
@Service
public class MalwareDetectionService {

    // Known malware signatures (MD5 hashes)
    private static final Set<String> KNOWN_MALWARE_HASHES = Set.of(
        "d41d8cd98f00b204e9800998ecf8427e", // Empty file (example)
        "5d41402abc4b2a76b9719d911017c592", // "hello" string
        "098f6bcd4621d373cade4e832627b4f6"  // "test" string
    );

    // Suspicious file patterns
    private static final List<Pattern> SUSPICIOUS_PATTERNS = Arrays.asList(
        Pattern.compile("(?i)eval\\s*\\(", Pattern.CASE_INSENSITIVE),
        Pattern.compile("(?i)exec\\s*\\(", Pattern.CASE_INSENSITIVE),
        Pattern.compile("(?i)system\\s*\\(", Pattern.CASE_INSENSITIVE),
        Pattern.compile("(?i)shell_exec", Pattern.CASE_INSENSITIVE),
        Pattern.compile("(?i)base64_decode", Pattern.CASE_INSENSITIVE),
        Pattern.compile("(?i)\\$_POST\\[", Pattern.CASE_INSENSITIVE),
        Pattern.compile("(?i)\\$_GET\\[", Pattern.CASE_INSENSITIVE),
        Pattern.compile("(?i)<script[^>]*>", Pattern.CASE_INSENSITIVE),
        Pattern.compile("(?i)javascript:", Pattern.CASE_INSENSITIVE),
        Pattern.compile("(?i)vbscript:", Pattern.CASE_INSENSITIVE)
    );

    // Suspicious file extensions
    private static final Set<String> SUSPICIOUS_EXTENSIONS = Set.of(
        ".exe", ".bat", ".cmd", ".com", ".pif", ".scr", ".vbs", ".js", ".jar", ".app"
    );

    // Maximum file sizes for different types (bytes)
    private static final Map<String, Long> MAX_FILE_SIZES = Map.of(
        "application/pdf", 50L * 1024 * 1024,        // 50MB
        "application/msword", 25L * 1024 * 1024,     // 25MB
        "application/vnd.openxmlformats-officedocument.wordprocessingml.document", 25L * 1024 * 1024,
        "image/jpeg", 10L * 1024 * 1024,             // 10MB
        "image/png", 10L * 1024 * 1024,              // 10MB
        "text/plain", 5L * 1024 * 1024               // 5MB
    );

    public MalwareDetectionResult scanFile(MultipartFile file) throws IOException {
        MalwareDetectionResult result = new MalwareDetectionResult();
        result.setFileName(file.getOriginalFilename());
        result.setFileSize(file.getSize());
        result.setMimeType(file.getContentType());

        // 1. File Hash Analysis
        String fileHash = calculateMD5Hash(file.getInputStream());
        result.setFileHash(fileHash);
        
        if (KNOWN_MALWARE_HASHES.contains(fileHash)) {
            result.setThreatDetected(true);
            result.addThreat("KNOWN_MALWARE_HASH", "File matches known malware signature");
            return result;
        }

        // 2. File Extension Analysis
        String fileName = file.getOriginalFilename();
        if (fileName != null) {
            String extension = getFileExtension(fileName).toLowerCase();
            if (SUSPICIOUS_EXTENSIONS.contains(extension)) {
                result.setThreatDetected(true);
                result.addThreat("SUSPICIOUS_EXTENSION", "Potentially dangerous file extension: " + extension);
            }
        }

        // 3. File Size Analysis
        if (isFileSizeAnomalous(file)) {
            result.setSuspicious(true);
            result.addWarning("ANOMALOUS_SIZE", "File size is unusually large for its type");
        }

        // 4. Content Pattern Analysis
        byte[] content = file.getBytes();
        analyzeFileContent(content, result);

        // 5. MIME Type Validation
        if (!isValidMimeType(file)) {
            result.setSuspicious(true);
            result.addWarning("MIME_MISMATCH", "File extension doesn't match MIME type");
        }

        // 6. Embedded Content Analysis
        analyzeEmbeddedContent(content, result);

        log.info("Malware scan completed for file: {} - Threat: {}, Suspicious: {}", 
                fileName, result.isThreatDetected(), result.isSuspicious());

        return result;
    }

    private String calculateMD5Hash(InputStream inputStream) throws IOException {
        try {
            MessageDigest md = MessageDigest.getInstance("MD5");
            byte[] buffer = new byte[8192];
            int bytesRead;
            
            while ((bytesRead = inputStream.read(buffer)) != -1) {
                md.update(buffer, 0, bytesRead);
            }
            
            byte[] hashBytes = md.digest();
            StringBuilder sb = new StringBuilder();
            for (byte b : hashBytes) {
                sb.append(String.format("%02x", b));
            }
            return sb.toString();
        } catch (NoSuchAlgorithmException e) {
            throw new RuntimeException("MD5 algorithm not available", e);
        }
    }

    private void analyzeFileContent(byte[] content, MalwareDetectionResult result) {
        String contentStr = new String(content);
        
        for (Pattern pattern : SUSPICIOUS_PATTERNS) {
            if (pattern.matcher(contentStr).find()) {
                result.setSuspicious(true);
                result.addWarning("SUSPICIOUS_PATTERN", "Found suspicious code pattern: " + pattern.pattern());
            }
        }

        // Check for excessive null bytes (potential binary in text file)
        int nullCount = 0;
        for (byte b : content) {
            if (b == 0) nullCount++;
        }
        
        if (nullCount > content.length * 0.1) { // More than 10% null bytes
            result.setSuspicious(true);
            result.addWarning("EXCESSIVE_NULL_BYTES", "File contains excessive null bytes");
        }
    }

    private void analyzeEmbeddedContent(byte[] content, MalwareDetectionResult result) {
        String contentStr = new String(content);
        
        // Check for embedded executables
        if (contentStr.contains("MZ") || contentStr.contains("PE")) {
            result.setThreatDetected(true);
            result.addThreat("EMBEDDED_EXECUTABLE", "File contains embedded executable code");
        }

        // Check for suspicious URLs
        if (contentStr.matches(".*https?://[^\\s]+\\.(exe|bat|cmd|scr).*")) {
            result.setSuspicious(true);
            result.addWarning("SUSPICIOUS_URL", "File contains URLs pointing to executable files");
        }

        // Check for obfuscated content
        long base64Count = contentStr.chars().mapToObj(c -> (char) c)
                .filter(c -> Character.isLetterOrDigit(c) || c == '+' || c == '/' || c == '=')
                .count();
        
        if (base64Count > content.length * 0.8) { // More than 80% base64-like characters
            result.setSuspicious(true);
            result.addWarning("POTENTIAL_OBFUSCATION", "File may contain obfuscated content");
        }
    }

    private boolean isFileSizeAnomalous(MultipartFile file) {
        String mimeType = file.getContentType();
        if (mimeType != null && MAX_FILE_SIZES.containsKey(mimeType)) {
            return file.getSize() > MAX_FILE_SIZES.get(mimeType);
        }
        return file.getSize() > 100L * 1024 * 1024; // Default 100MB limit
    }

    private boolean isValidMimeType(MultipartFile file) {
        String fileName = file.getOriginalFilename();
        String mimeType = file.getContentType();
        
        if (fileName == null || mimeType == null) return false;
        
        String extension = getFileExtension(fileName).toLowerCase();
        
        // Basic MIME type validation
        Map<String, String> expectedMimeTypes = Map.of(
            ".pdf", "application/pdf",
            ".doc", "application/msword",
            ".docx", "application/vnd.openxmlformats-officedocument.wordprocessingml.document",
            ".txt", "text/plain",
            ".jpg", "image/jpeg",
            ".jpeg", "image/jpeg",
            ".png", "image/png"
        );
        
        String expectedMime = expectedMimeTypes.get(extension);
        return expectedMime == null || expectedMime.equals(mimeType);
    }

    private String getFileExtension(String fileName) {
        int lastDot = fileName.lastIndexOf('.');
        return lastDot > 0 ? fileName.substring(lastDot) : "";
    }

    // Result class
    public static class MalwareDetectionResult {
        private String fileName;
        private long fileSize;
        private String mimeType;
        private String fileHash;
        private boolean threatDetected = false;
        private boolean suspicious = false;
        private List<ThreatInfo> threats = new ArrayList<>();
        private List<ThreatInfo> warnings = new ArrayList<>();

        // Getters and setters
        public String getFileName() { return fileName; }
        public void setFileName(String fileName) { this.fileName = fileName; }
        
        public long getFileSize() { return fileSize; }
        public void setFileSize(long fileSize) { this.fileSize = fileSize; }
        
        public String getMimeType() { return mimeType; }
        public void setMimeType(String mimeType) { this.mimeType = mimeType; }
        
        public String getFileHash() { return fileHash; }
        public void setFileHash(String fileHash) { this.fileHash = fileHash; }
        
        public boolean isThreatDetected() { return threatDetected; }
        public void setThreatDetected(boolean threatDetected) { this.threatDetected = threatDetected; }
        
        public boolean isSuspicious() { return suspicious; }
        public void setSuspicious(boolean suspicious) { this.suspicious = suspicious; }
        
        public List<ThreatInfo> getThreats() { return threats; }
        public List<ThreatInfo> getWarnings() { return warnings; }
        
        public void addThreat(String type, String description) {
            threats.add(new ThreatInfo(type, description));
        }
        
        public void addWarning(String type, String description) {
            warnings.add(new ThreatInfo(type, description));
        }

        public boolean isClean() {
            return !threatDetected && !suspicious;
        }
    }

    public static class ThreatInfo {
        private String type;
        private String description;
        
        public ThreatInfo(String type, String description) {
            this.type = type;
            this.description = description;
        }
        
        public String getType() { return type; }
        public String getDescription() { return description; }
    }
}
